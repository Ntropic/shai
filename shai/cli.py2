import argparse, subprocess, sys
from typing import List

from .config import load_settings
from .util.ansi import BOLD, DIM, GREEN, RED, CYAN
from .util.shellparse import extract_commands
from .ui.table import ColSpec, grid_select
from .llm.suggest import request_suggestions


INSTALLERS = {"pacman","yay","paru","apt","dnf","zypper","brew","flatpak","snap"}

def _stdin_capture(enabled=True):
    if not enabled: return ""
    if sys.stdin and not sys.stdin.isatty():
        data = sys.stdin.read()
        return "\n".join(l.rstrip() for l in data.splitlines())[-4000:]
    return ""

def _gather_context(cfg):
    import os, platform, shutil
    ctx = {
        "os": platform.system(),
        "shell": os.environ.get("SHELL"),
        "editor": os.environ.get("VISUAL") or os.environ.get("EDITOR"),
        "pm_order": cfg.pm_order,
        "stdin": _stdin_capture(cfg.use_stdin),
        "num_ctx": cfg.num_ctx,
    }
    ctx["package_managers"] = [pm for pm in cfg.pm_order if shutil.which(pm)]
    return ctx

def _is_installer_command(cmd: str) -> bool:
    bins = extract_commands(cmd)
    return bool(bins and bins[0] in INSTALLERS)

def main(argv: List[str] | None = None) -> int:
    ap = argparse.ArgumentParser(prog="shai", description="Natural language → CLI suggestions via Ollama.")
    ap.add_argument("query", nargs="*", help="what you want to do (natural language)")
    ap.add_argument("-n","--num", type=int, help="number of suggestions")
    ap.add_argument("-e","--explain", action="store_true", help="show explanations")
    ap.add_argument("--no-explain", action="store_true", help="hide explanations")
    ap.add_argument("--model")
    ap.add_argument("--ctx", type=int, help="override context window (num_ctx)")
    args = ap.parse_args(argv)

    cfg = load_settings()

    model  = args.model or cfg.model
    num    = cfg.n_suggestions if args.num is None else max(1, args.num)
    num_ctx = cfg.num_ctx if args.ctx is None else max(512, int(args.ctx))

    if args.explain and args.no_explain: show_explain = True
    elif args.explain:                   show_explain = True
    elif args.no_explain:                show_explain = False
    else:                                show_explain = cfg.explain

    query = " ".join(args.query).strip()
    if not query:
        print("Example: shai -n 3 --ctx 8192 'find big .log files and summarize'"); return 1

    ctx = _gather_context(cfg)
    suggestions = request_suggestions(model, query, num, ctx, num_ctx)
    if not suggestions:
        print(RED("No suggestions returned.")); return 2

    # Build rows
    rows = []
    for s in suggestions:
        missing = [b for b,p in (s.requires or {}).items() if not p]
        if show_explain:
            status = (RED(f"missing: {', '.join(missing)}") if missing else GREEN("all tools present"))
            if s.explanation_min:
                status = f"{status}\n{DIM(s.explanation_min)}"
            rows.append((s.command, status))
        else:
            msg = s.command
            if missing:
                msg += f"\n{RED('missing: ' + ', '.join(missing))}"
            rows.append((msg,))

    # Columns
    if show_explain:
        colspecs = [
            ColSpec(header="Command", min_width=20, wrap=False, ellipsis=True),
            ColSpec(header="Status / Explanation", min_width=20, wrap=True),
        ]
    else:
        colspecs = [ColSpec(header="Command", min_width=20, wrap=True)]

    def menu_for_row(i: int): return ["Execute", "Explain", "Comment", "Execute → continue"]

    while True:
        action, row_idx, sub_idx = grid_select(rows, colspecs, row_menu_provider=menu_for_row,
                                               submenu_cols=3, title=" Suggestions ")
        if action in ("quit",) or row_idx is None:
            print(DIM("Done.")); return 0

        chosen = suggestions[row_idx]
        missing = [b for b,p in (chosen.requires or {}).items() if not p]

        if action == "submenu-selected":
            # Execute / Execute → continue
            if sub_idx in (0, 3):
                if missing:
                    print(RED(f"\nMissing tools: {', '.join(missing)}"))
                    print(DIM("Package install suggestions not yet implemented."))
                    input(DIM("\nPress Enter to return…"))
                    continue
                print(BOLD("Running: ") + chosen.command + "\n")
                rc = subprocess.call(chosen.command, shell=True)
                if sub_idx == 3 or _is_installer_command(chosen.command):
                    input(DIM("\nPress Enter to return…"))
                    continue
                return rc
            # Explain
            if sub_idx == 1:
                print(BOLD("\nExplanation:"))
                if chosen.explanation_min:
                    print(chosen.explanation_min)
                else:
                    print(DIM("(no explanation provided by the model)"))
                print(BOLD("\nTools:"))
                for b,p in (chosen.requires or {}).items():
                    print(f"  {b:10} {'✓ '+p if p else '✗ missing'}")
                input(DIM("\nPress Enter to return…"))
                continue
            # Comment
            if sub_idx == 2:
                try: note = input("\nYour comment about this suggestion: ").strip()
                except KeyboardInterrupt: note = ""
                if note: print(GREEN("Thanks! Comment captured (stdout)."))
                else:    print(DIM("No comment entered."))
                input(DIM("\nPress Enter to return…"))
                continue

        if action == "row-selected":  # normally unused
            print(BOLD("Running: ") + chosen.command + "\n")
            return subprocess.call(chosen.command, shell=True)

if __name__ == "__main__":
    raise SystemExit(main())
